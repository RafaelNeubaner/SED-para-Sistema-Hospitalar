#include "Escalonador.hpp"
#include "Fila.hpp"
#include "Paciente.hpp"
#include "Procedimento.hpp"

int main()
{
    std::ifstream arquivo("arquivo.csv");
    if (!arquivo.is_open())
    {
        std::cout << "ERRO: NAO FOI POSSIVEL ABRIR O ARQUIVO" << std::endl;
    }
    int npessoas;
    Procedimento *p = new Procedimento(arquivo);
    arquivo >> npessoas;
    int tamanho_fila = (npessoas * (3 / 5));
    Paciente *pacientes = new Paciente[npessoas];
    MinHeap fila0triagem(tamanho_fila);
    MinHeap fila1triagem(tamanho_fila);
    MinHeap fila2triagem(tamanho_fila);
    MinHeap fila0atendimento(tamanho_fila);
    MinHeap fila1atendimento(tamanho_fila);
    MinHeap fila2atendimento(tamanho_fila);
    MinHeap fila0medidas(tamanho_fila);
    MinHeap fila1medidas(tamanho_fila);
    MinHeap fila2medidas(tamanho_fila);
    MinHeap fila0testes(tamanho_fila);
    MinHeap fila1testes(tamanho_fila);
    MinHeap fila2testes(tamanho_fila);
    MinHeap fila0imagem(tamanho_fila);
    MinHeap fila1imagem(tamanho_fila);
    MinHeap fila2imagem(tamanho_fila);
    MinHeap fila0instrumentos(tamanho_fila);
    MinHeap fila1instrumentos(tamanho_fila);
    MinHeap fila2instrumentos(tamanho_fila);
    for (int i = 0; i < npessoas; i++)
    {
        Paciente *p = new Paciente(arquivo);
        pacientes[i] = *p;
    }

    for (int i = 0; i < npessoas; i++)
    {
        //escalona(&pacientes[i], &fila0triagem, &fila0atendimento, &fila0medidas, &fila0testes, &fila0imagem, &fila0instrumentos, &fila1triagem, &fila1atendimento, &fila1medidas, &fila1testes, &fila1imagem, &fila1instrumentos, &fila2triagem, &fila2atendimento, &fila2medidas, &fila2testes, &fila2imagem, &fila2instrumentos, p);
    }

}

#include "Escalonador.hpp"

void escalona(Paciente *P, MinHeap *triagem0, MinHeap *atendimento0, MinHeap *medidas0, MinHeap *testes0, MinHeap *imagem0, MinHeap *instrumentos0, MinHeap *triagem1, MinHeap *atendimento1, MinHeap *medidas1, MinHeap *testes1, MinHeap *imagem1, MinHeap *instrumentos1, MinHeap *triagem2, MinHeap *atendimento2, MinHeap *medidas2, MinHeap *testes2, MinHeap *imagem2, MinHeap *instrumentos2, Procedimento *Pro)
{
    switch (P->grau)
    {
    case 0:
        insere_fila0(P, triagem0, atendimento0, medidas0, testes0, imagem0, instrumentos0, Pro);
        break;
    case 1:
        insere_fila1(P, triagem1, atendimento1, medidas1, testes1, imagem1, instrumentos1, Pro);
        break;
    case 2:
        insere_fila2(P, triagem2, atendimento2, medidas2, testes2, imagem2, instrumentos2, Pro);
        break;

    default:
        break;
    }
}

void desescalona(MinHeap *triagem0, MinHeap *atendimento0, MinHeap *medidas0, MinHeap *testes0, MinHeap *imagem0, MinHeap *instrumentos0, MinHeap *triagem1, MinHeap *atendimento1, MinHeap *medidas1, MinHeap *testes1, MinHeap *imagem1, MinHeap *instrumentos1, MinHeap *triagem2, MinHeap *atendimento2, MinHeap *medidas2, MinHeap *testes2, MinHeap *imagem2, MinHeap *instrumentos2, Procedimento *Pro)
{
    if ((triagem0->tamanho || triagem1->tamanho || triagem2->tamanho) != 0)
    {
        /* code */
    }
}

void insere_fila0(Paciente *P, MinHeap *triagem, MinHeap *atendimento, MinHeap *medidas, MinHeap *testes, MinHeap *imagem, MinHeap *instrumentos, Procedimento *Pro)
{
    if (P->triado == 0)
    {
        triagem->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->atendido == 0)
    {
        atendimento->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->nmh != 0)
    {
        medidas->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->ntl != 0)
    {
        testes->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->nei != 0)
    {
        imagem->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->nim != 0)
    {
        instrumentos->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
}

void insere_fila1(Paciente *P, MinHeap *triagem, MinHeap *atendimento, MinHeap *medidas, MinHeap *testes, MinHeap *imagem, MinHeap *instrumentos, Procedimento *Pro)
{
    if (P->triado == 0)
    {
        triagem->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->atendido == 0)
    {
        atendimento->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->nmh != 0)
    {
        medidas->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->ntl != 0)
    {
        testes->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->nei != 0)
    {
        imagem->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->nim != 0)
    {
        instrumentos->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
}

void insere_fila2(Paciente *P, MinHeap *triagem, MinHeap *atendimento, MinHeap *medidas, MinHeap *testes, MinHeap *imagem, MinHeap *instrumentos, Procedimento *Pro)
{
    if (P->triado == 0)
    {
        triagem->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->atendido == 0)
    {
        atendimento->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->nmh != 0)
    {
        medidas->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->ntl != 0)
    {
        testes->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->nei != 0)
    {
        imagem->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
    else if (P->nim != 0)
    {
        instrumentos->inserir(*P);
        P->conta_hora(Pro);
        return;
    }
}

#include "Fila.hpp"

// Construtor do MinHeap
MinHeap::MinHeap() {}
MinHeap::MinHeap(int capacidade)
    : capacidade(capacidade), tamanho(0)
{
    heap = new Paciente[capacidade]; // Alocação dinâmica do array
}

// Destrutor do MinHeap
MinHeap::~MinHeap()
{
    delete[] heap; // Libera a memória alocada dinamicamente
}

// Função para obter o índice do pai
int MinHeap::pai(int i)
{
    return (i - 1) / 2;
}

// Função para obter o índice do filho à esquerda
int MinHeap::filhoEsquerdo(int i)
{
    return 2 * i + 1;
}

// Função para obter o índice do filho à direita
int MinHeap::filhoDireito(int i)
{
    return 2 * i + 2;
}

// Função para trocar dois elementos no heap
void MinHeap::troca(int i, int j)
{
    Paciente temp = heap[i];
    heap[i] = heap[j];
    heap[j] = temp;
}

// Função para organizar o heap para cima (up-heap)
void MinHeap::subir(int i)
{
    while (i > 0 && comparar(heap[i], heap[pai(i)]))
    {
        troca(i, pai(i));
        i = pai(i);
    }
}

// Função para organizar o heap para baixo (down-heap)
void MinHeap::descer(int i)
{
    int menor = i;
    int esquerdo = filhoEsquerdo(i);
    int direito = filhoDireito(i);

    // Verifica o filho à esquerda
    if (esquerdo < tamanho && comparar(heap[esquerdo], heap[menor]))
    {
        menor = esquerdo;
    }

    // Verifica o filho à direita
    if (direito < tamanho && comparar(heap[direito], heap[menor]))
    {
        menor = direito;
    }

    // Se o menor elemento não for o pai, troca e continua descendo
    if (menor != i)
    {
        troca(i, menor);
        descer(menor);
    }
}

// Função para comparar dois pacientes (baseado em prioridade e hora de chegada)
bool MinHeap::comparar(const Paciente &p1, const Paciente &p2)
{
    if (p1.horafila != p2.horafila)
    {
        return p1.horafila < p2.horafila; // Menor prioridade tem preferência
    }
    //    return p1.horaChegada < p2.horaChegada; // Desempate pela hora de chegada
}

// Função para redimensionar o heap
void MinHeap::redimensionar()
{
    int novaCapacidade = (capacidade * (3 / 2)); // Dobra a capacidade
    Paciente *novoHeap = new Paciente[novaCapacidade];

    for (int i = 0; i < tamanho; i++)
    {
        novoHeap[i] = heap[i];
    }

    heap = novoHeap;
    delete[] heap; // Libera a memória antiga
    capacidade = novaCapacidade;
}

// Função para inserir um paciente no heap
void MinHeap::inserir(Paciente p)
{
    if (tamanho >= capacidade)
    {
        redimensionar(); // Redimensiona o heap se necessário
    }
    heap[tamanho] = p;
    subir(tamanho);
    tamanho++;
}

// Função para remover o paciente com maior prioridade
Paciente MinHeap::remover()
{

    Paciente raiz = heap[0];
    heap[0] = heap[tamanho - 1];
    tamanho--;
    descer(0);
    return raiz;
}

// Função para verificar se o heap está vazio
bool MinHeap::vazio() const
{
    return tamanho == 0;
}

#include "Paciente.hpp"

Paciente::Paciente(std::ifstream &arquivo)
{
    arquivo >> this->id;
    arquivo >> this->alta;
    arquivo >> this->anoin;
    arquivo >> this->mesin;
    arquivo >> this->diain;
    arquivo >> this->horain;
    arquivo >> this->grau;
    arquivo >> this->nmh;
    arquivo >> this->ntl;
    arquivo >> this->nei;
    arquivo >> this->nim;
    horafila = horain;
}

void Paciente::print_paciente(Paciente *paciente)
{
    std::cout << paciente->id << " "
              << paciente->diain << " "
              << paciente->mesin << " "
              << paciente->diain << " "
              << paciente->horain << " "
              << paciente->anoin << " "
              << paciente->diaout << " "
              << paciente->mesout << " "
              << paciente->diaout << " "
              << paciente->horaout << " "
              << paciente->anoout << " "
              << paciente->ttot << " "
              << paciente->tat << " "
              << paciente->tesp << std::endl;
}
Paciente::Paciente() {}

void Paciente::conta_hora(Procedimento *procedimento)
{
    if (triado == 0)
    {
        horafila += (procedimento->ttri);
        triado++;
    }
    else if (atendido == 0)
    {
        horafila += procedimento->taten + tparc;
        atendido++;
    }
    else if (nmh != 0)
    {
        horafila += (nmh * procedimento->tm) + tparc;
        nmh = 0;
    }
    else if (ntl != 0)
    {
        horafila += (ntl * procedimento->tt) + tparc;
        ntl = 0;
    }
    else if (nei != 0)
    {
        horafila += (nei * procedimento->ti) + tparc;
        nei = 0;
    }
    else if (nim != 0)
    {
        horafila += (nim * procedimento->tmin) + tparc;
        nim = 0;
    }
}

#include "Procedimento.hpp"

Sala::Sala()
{
    relogio = 0.0;
    cheio = 0;
}

Sala::~Sala()
{
}

Procedimento::Procedimento(std::ifstream &arquivo) // construtor do tad procedimento que utiliza um arquivo como parametro para preencher as informações
{
    arquivo >> this->ttri;
    arquivo >> this->ntri;

    arquivo >> this->taten;
    arquivo >> this->naten;

    arquivo >> this->tm;
    arquivo >> this->nm;

    arquivo >> this->tt;
    arquivo >> this->nt;

    arquivo >> this->ti;
    arquivo >> this->ni;

    arquivo >> this->tim;
    arquivo >> this->nim;
    triagem = new Sala[ntri];
    atendimento = new Sala[naten];
    medidas = new Sala[nm];
    testes = new Sala[nt];
    imagem = new Sala[ni];
    instrumentos = new Sala[nim];
}
bool Procedimento::checa(int x, Paciente *p) // função responsavel por testar se há salas vazias para o procedimento cujo indice foi informado
{
    switch (x)
    {
    case 0:
    {
        for (size_t i = 0; i < ntri; i++)
        {
            if (p->horafila >)
            {
                return 1;
            }
        }
    }
    break;
    case 1:
    {
        for (size_t i = 0; i < naten; i++)
        {
            if (atendimento[i].cheio)
            {
                return 1;
            }
        }
    }
    break;
    case 2:
    {
        for (size_t i = 0; i < nm; i++)
        {
            if (medidas[i].cheio)
            {
                return 1;
            }
        }
    }
    break;
    case 3:
    {
        for (size_t i = 0; i < nt; i++)
        {
            if (testes[i].cheio)
            {
                return 1;
            }
        }
    }
    break;
    case 4:
    {
        for (size_t i = 0; i < ni; i++)
        {
            if (imagem[i].cheio)
            {
                return 1;
            }
        }
    }
    break;
    case 5:
    {
        for (size_t i = 0; i < nim; i++)
        {
            if (instrumentos[i].cheio)
            {
                return 1;
            }
        }
    }
    break;
    default:
        break;
    }
}

Procedimento::~Procedimento()
{
    delete[] triagem;
    delete[] atendimento;
    delete[] medidas;
    delete[] testes;
    delete[] imagem;
    delete[] instrumentos;
}
